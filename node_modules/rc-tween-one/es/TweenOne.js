import _extends from 'babel-runtime/helpers/extends';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import ReactDom from 'react-dom';
import { stylesToCss } from 'style-utils';

import { dataToArray, objectEqual } from './util';
import Tween from './Tween';
import ticker from './ticker';

function noop() {}

var perFrame = Math.round(1000 / 60);
var objectOrArray = PropTypes.oneOfType([PropTypes.object, PropTypes.array]);

var TweenOne = function (_Component) {
  _inherits(TweenOne, _Component);

  function TweenOne(props) {
    _classCallCheck(this, TweenOne);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _initialiseProps.call(_this);

    _this.rafID = -1;
    _this.moment = props.moment || 0;
    _this.startMoment = props.moment || 0;
    _this.startFrame = ticker.frame;
    _this.paused = props.paused;
    _this.reverse = props.reverse;
    _this.newMomentAnim = false;
    _this.updateAnim = null;
    _this.forced = {};
    _this.setForcedJudg(props);
    return _this;
  }

  TweenOne.prototype.componentDidMount = function componentDidMount() {
    this.dom = ReactDom.findDOMNode(this);
    if (this.dom && this.dom.nodeName !== '#text') {
      this.start();
    }
  };

  TweenOne.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (!this.tween && !this.dom) {
      this.updateAnim = 'start';
      return;
    }
    // 跳帧事件 moment;
    var newMoment = nextProps.moment;
    this.newMomentAnim = false;
    if (typeof newMoment === 'number' && newMoment !== this.moment) {
      this.startMoment = newMoment;
      this.startFrame = ticker.frame;
      if (this.rafID === -1 && !nextProps.paused) {
        this.tween.resetAnimData();
        var style = nextProps.style;
        this.dom.setAttribute('style', '');
        if (style) {
          Object.keys(style).forEach(function (key) {
            _this2.dom.style[key] = stylesToCss(key, style[key]);
          });
        }
        this.play();
      } else {
        this.newMomentAnim = true;
      }
    }
    // 动画处理
    var newAnimation = nextProps.animation;
    var currentAnimation = this.props.animation;
    var equal = objectEqual(currentAnimation, newAnimation);
    var styleEqual = objectEqual(this.props.style, nextProps.style);
    // 如果 animation 不同， 在下一帧重新动画
    if (!equal) {
      // 在有动画的情况下才可以执行 resetDefaultStyle; 避免无动画时也把 style 刷成默认状态。
      if (nextProps.resetStyleBool && this.tween && this.rafID === -1) {
        this.tween.resetDefaultStyle();
      }
      if (this.rafID !== -1) {
        this.updateAnim = 'update';
      } else if (nextProps.updateReStart) {
        this.startFrame = ticker.frame;
        this.updateAnim = 'start';
      }
      // 只做动画，不做回调处理。。。
      if (this.tween) {
        this.tween.updateAnim = this.updateAnim;
      }
    }

    if (!styleEqual) {
      // 在动画时更改了 style, 作为更改开始数值。
      if (this.rafID !== -1) {
        this.updateStartStyle = true;
      }
    }

    // 暂停倒放
    if (this.paused !== nextProps.paused || this.reverse !== nextProps.reverse) {
      this.paused = nextProps.paused;
      this.reverse = nextProps.reverse;
      if (this.paused) {
        this.cancelRequestAnimationFrame();
      } else if (this.reverse && nextProps.reverseDelay) {
        this.cancelRequestAnimationFrame();
        ticker.timeout(this.restart, nextProps.reverseDelay);
      } else {
        this.restart();
      }
    }

    this.setForcedJudg(nextProps);
  };

  TweenOne.prototype.componentDidUpdate = function componentDidUpdate() {
    if (!this.dom || this.dom.nodeName !== '#text') {
      this.dom = ReactDom.findDOMNode(this);
    }
    if (this.tween) {
      if (this.updateStartStyle && !this.updateAnim) {
        this.tween.reStart(this.props.style);
        this.updateStartStyle = false;
      }

      if (this.newMomentAnim) {
        this.raf();
      }
    }
    // 样式更新了后再执行动画；
    if (this.updateAnim === 'start' && this.dom && this.dom.nodeName !== '#text') {
      this.start();
    }
  };

  TweenOne.prototype.componentWillUnmount = function componentWillUnmount() {
    this.cancelRequestAnimationFrame();
  };

  /**
   * @method setForcedJudg
   * @param props
   * QueueAnim 套在组件下面后导至子级变化。
   * <QueueAnim component={Menu} >
   *   <SubMenu key="a" title="导航">
   *     <Item />
   *   </SubMenu>
   * </QueueAnim>
   * rc-Menu 里是以 isXXX 来判断是 rc-Menu 的子级;
   * 如: 用 isSubMenu 来处理 hover 事件
   * 地址: https://github.com/react-component/menu/blob/master/src/MenuMixin.js#L172
   * 暂时方案: 在组件里添加判断用的值。
   */

  TweenOne.prototype.render = function render() {
    var props = _extends({}, this.props);
    ['animation', 'component', 'componentProps', 'reverseDelay', 'attr', 'paused', 'reverse', 'repeat', 'yoyo', 'moment', 'resetStyleBool', 'updateReStart', 'forcedJudg'].forEach(function (key) {
      return delete props[key];
    });
    props.style = _extends({}, this.props.style);
    Object.keys(props.style).forEach(function (p) {
      if (p.match(/filter/i)) {
        ['Webkit', 'Moz', 'Ms', 'ms'].forEach(function (prefix) {
          props.style[prefix + 'Filter'] = props.style[p];
        });
      }
    });
    // component 为空时调用子级的。。
    if (!this.props.component) {
      if (!this.props.children) {
        return this.props.children;
      }
      var childrenProps = this.props.children.props;
      var style = childrenProps.style,
          className = childrenProps.className;
      // 合并 style 与 className。

      var newStyle = _extends({}, style, props.style);
      var newClassName = props.className ? props.className + ' ' + className : className;
      return React.cloneElement(this.props.children, { style: newStyle, className: newClassName });
    }
    return React.createElement(this.props.component, _extends({}, props, this.props.componentProps));
  };

  return TweenOne;
}(Component);

TweenOne.propTypes = {
  component: PropTypes.any,
  componentProps: PropTypes.any,
  animation: objectOrArray,
  children: PropTypes.any,
  style: PropTypes.object,
  paused: PropTypes.bool,
  reverse: PropTypes.bool,
  reverseDelay: PropTypes.number,
  yoyo: PropTypes.bool,
  repeat: PropTypes.number,
  moment: PropTypes.number,
  attr: PropTypes.string,
  onChange: PropTypes.func,
  resetStyleBool: PropTypes.bool,
  updateReStart: PropTypes.bool,
  forcedJudg: PropTypes.object
};
TweenOne.defaultProps = {
  component: 'div',
  componentProps: {},
  reverseDelay: 0,
  repeat: 0,
  attr: 'style',
  onChange: noop,
  updateReStart: true
};

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.setForcedJudg = function (props) {
    Object.keys(_this3.forced).forEach(function (key) {
      delete _this3[key];
      delete _this3.forced[key];
    });
    if (props.forcedJudg) {
      Object.keys(props.forcedJudg).forEach(function (key) {
        if (!_this3[key]) {
          _this3[key] = props.forcedJudg[key];
          _this3.forced[key] = 1;
        }
      });
    }
  };

  this.restart = function () {
    if (!_this3.tween) {
      return;
    }
    _this3.startMoment = _this3.moment;
    _this3.startFrame = ticker.frame;
    _this3.tween.reverse = _this3.reverse;
    _this3.tween.reverseStartTime = _this3.startMoment;
    _this3.play();
  };

  this.start = function () {
    _this3.updateAnim = null;
    var props = _this3.props;
    if (props.animation && Object.keys(props.animation).length) {
      _this3.tween = new Tween(_this3.dom, dataToArray(props.animation), { attr: props.attr });
      // 预先注册 raf, 初始动画数值。
      _this3.raf();
      // 开始动画
      _this3.play();
    }
  };

  this.play = function () {
    _this3.cancelRequestAnimationFrame();
    if (_this3.paused) {
      return;
    }
    _this3.rafID = ticker.add(_this3.raf);
  };

  this.updateAnimFunc = function () {
    _this3.cancelRequestAnimationFrame();
    _this3.startFrame = ticker.frame;
    if (_this3.updateAnim === 'update') {
      if (_this3.props.resetStyleBool && _this3.tween) {
        _this3.tween.resetDefaultStyle();
      }
      _this3.startMoment = 0;
    }
  };

  this.frame = function () {
    var yoyo = _this3.props.yoyo;
    var repeat = _this3.props.repeat;

    var totalTime = repeat === -1 ? Number.MAX_VALUE : _this3.tween.totalTime * (repeat + 1);
    repeat = repeat >= 0 ? repeat : Number.MAX_VALUE;
    var moment = (ticker.frame - _this3.startFrame) * perFrame + _this3.startMoment;
    if (_this3.reverse) {
      moment = (_this3.startMoment || 0) - (ticker.frame - _this3.startFrame) * perFrame;
    }
    moment = moment > totalTime ? totalTime : moment;
    moment = moment <= 0 ? 0 : moment;
    var repeatNum = Math.floor(moment / _this3.tween.totalTime) || 0;
    repeatNum = repeatNum > repeat ? repeat : repeatNum;
    var tweenMoment = moment - _this3.tween.totalTime * repeatNum;
    tweenMoment = tweenMoment < perFrame ? 0 : tweenMoment;
    if (repeat && moment && moment - _this3.tween.totalTime * repeatNum < perFrame) {
      // 在重置样式之前补 complete；
      _this3.tween.frame(_this3.tween.totalTime * repeatNum);
    }
    if (moment < _this3.moment && !_this3.reverse || repeat !== 0 && repeatNum && tweenMoment <= perFrame) {
      _this3.tween.resetDefaultStyle();
    }
    var yoyoReverse = yoyo && repeatNum % 2;
    if (yoyoReverse) {
      tweenMoment = _this3.tween.totalTime - tweenMoment;
    }
    _this3.tween.onChange = function (e) {
      var cb = _extends({}, e, {
        timelineMode: ''
      });
      if (!moment && !_this3.reverse || _this3.reverse && _this3.moment === _this3.startMoment) {
        cb.timelineMode = 'onTimelineStart';
      } else if (moment >= totalTime && !_this3.reverse || !moment && _this3.reverse) {
        cb.timelineMode = 'onTimelineComplete';
      } else if (repeatNum !== _this3.timelineRepeatNum) {
        cb.timelineMode = 'onTimelineRepeat';
      } else {
        cb.timelineMode = 'onTimelineUpdate';
      }
      _this3.props.onChange(cb);
    };
    _this3.tween.frame(tweenMoment);
    _this3.moment = moment;
    _this3.timelineRepeatNum = repeatNum;
  };

  this.raf = function () {
    var _props = _this3.props,
        repeat = _props.repeat,
        style = _props.style;

    var totalTime = repeat === -1 ? Number.MAX_VALUE : _this3.tween.totalTime * (repeat + 1);
    /**
      * 踩坑：frame 在前面，所以 onComplete 在 updateAnim 前调用，
      * 如果在 onComplete 改变样式，将会把 updateAnim 值更改，导到此处调用。
      * 事件需在当前帧频之前全部被处理完成, 如果在帧上改变了动画参数，直接退出并重新开始
      * 提到 this.frame 之上；
      * link: https://github.com/ant-design/ant-motion/issues/165
      */
    if (_this3.updateAnim) {
      _this3.cancelRequestAnimationFrame();
      if (_this3.updateStartStyle) {
        _this3.tween.reStart(style);
      }
      _this3.updateAnimFunc();
      _this3.start();
      return null;
    }
    _this3.frame();
    if (_this3.moment >= totalTime && !_this3.reverse || _this3.paused || _this3.reverse && _this3.moment === 0) {
      return _this3.cancelRequestAnimationFrame();
    }
    return null;
  };

  this.cancelRequestAnimationFrame = function () {
    ticker.clear(_this3.rafID);
    _this3.rafID = -1;
  };
};

TweenOne.isTweenOne = true;
export default TweenOne;